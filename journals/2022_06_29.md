- # 至多包含两个不同字符串的最长子串 #[[alg/again]]
- [159. 至多包含两个不同字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
- 讲述了滑动窗口的大致解题思路
  https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solution/hua-dong-chuang-kou-zhen-di-jian-dan-yi-73bii/
- # 相隔为 1 的编辑举例 #[[alg/again]]
	- [161. 相隔为 1 的编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/one-edit-distance/)
	- 这道题虽然写出来了，但是实现过程还可以再优雅一点。
- # 重建二叉树 #[[alg/again]]
	- [剑指 Offer 07. 重建二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)
	- 难度不大，但是这道题经常做到，会用到前序遍历、中序遍历、递归等知识点，可以多练习一次。
- # 单词的最大乘积 #[[alg/again]]
	- [剑指 Offer II 005. 单词长度的最大乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/aseY1I/)
	- 优化点：将单词中的字幕字母映射到 0-25 的数字中，然后使用位与算法，可以计算出每个单词的值。如果两个单词的值进行 &，大于 0 则表示存在重复。
- # [[算法]]学习路径 #[[alg/schedule]]
	- **目标：**
		- 大多数数据结构的题都要做过，并且实现相应的数据结构。数组、链表、跳表、队列、栈、优先队列、二叉树、前缀树、并查集。
		- 了解常见的算法。比如 dfs、bfs、滑动窗口、单调栈、动态规划。
	- **资源：**
	- 剑指 offer（第 2 版）：https://leetcode.cn/problem-list/xb9nqhhg/
	- leetcode hot 100：https://leetcode.cn/problem-list/2cktkvj/
	- 程序员面试金典（第 6 版）：https://leetcode.cn/problem-list/xb9lfcwi/
- # 旋转数组最小值 #[[alg/again]]
	- [剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)
	- 算是二分法的变式。需要注意当 nums[mid] == nums[left] 时，是无法判断区间的，需要将 right = right - 1，在做判断。 为什么不能用 nums[mid] 和 nums[left]进行判断？因为当 nums[mid] > nums[left] 时并不能判断最小数在哪个区域，有歧义。 比如下面两个数组使用nums[mid] 和 nums[left] 进行判断结果是错误的：
	  [1,2,3,4,5]
	  [3,4,5,1,2]
	- 参考：
		- https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/
- # 最长不含重复字符的字符串 #[[alg/again]]
	- [剑指 Offer 48. 最长不含重复字符的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)
	- 通用方法是使用一个状态数组+快慢指针来解决。
- # 数组中出现次数超过一半的数字 #[[alg/again]]
	- [剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)
	- 这道题也可以用快速单边排序来做，但是使用摩尔投票法会更加地快速。
- # 二叉搜索树与双向链表 #[[alg/again]]
	- [剑指 Offer 36. 二叉搜索树与双向链表 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)
	- 中序遍历确定顺序，前后指针连接。
	- 参考：
		- https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
- # 二叉搜索树的后序遍历 #[[alg/again]]
	- [剑指 Offer 33. 二叉搜索树的后序遍历序列 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)
	- 主要是用到了分治的思想，把整棵树是否为二叉搜索树分割成左子树和右子树是否是二叉搜索树这两个子问题。
- # 栈的压入、弹出序列 #[[alg/again]]
	- [剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode）](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)
	- 新建辅助栈，注意退出的边界条件。
- # 表示数值的字符串 #[[alg/again]]
	- [剑指 Offer 20. 表示数值的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)
	- 参考：
	  https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/
	- 可以看下状态机，以及评论里有一个用 c++实现的算法。注意边界条件。
- # 二进制中 1 的个数 #[[alg/again]]
	- [剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)
	- 这道题常规做法是循环，不过还可以通过 n & (n-1) 这个小技巧来快速找到 1 的个数。
	- 为什么这种算法行得通，得分两种情况讨论：
	  1. 低位是 1，那么 n&(n-1) = 0，去除了一个 1。
	  2. 低位为 0，那么 n-1，会把最近的一个 1 置为 0，然后后面 0 置为 1，n&(n-1)=0 结果不变。
	- 其实两种情况可以合并为一个结论：就是把最近的一个 1 置为，然后随后的 0 全部置为 1，结果 为 0。这样翻转 M（1 的个数），就能返回结果。
- # 数值的整数次方 #[[alg/again]]
	- [剑指 Offer 16. 数值的整数次方 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)
	- 递归方法比较清晰，如何使用非递归去解决问题？
	  递归是采用回溯，那么如何使用循环去描述自底向下的过程。
- # 树的子结构 #[[alg/again]]
	- [剑指 Offer 26. 树的子结构 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)
	- 改题目主要是使用了递归的思路。第一做了出来，但是解法比较耦合。新的解法将遍历 A 和判断 B 是否是 A 的子树这两个逻辑区分开发。更加直观。
- # 只出现一次的数字 #[[alg/again]]
	- [剑指 Offer II 004. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/WGki4K/)
	- 使用一个 64 长度的数组，存放每个数字的每位的值，因为只有一个元素出现过一次，其余都是 3 次，那么就可以对这个数组做 `arr[i] % 3` 的操作，拿到那个元素每一位的值，然后得出答案。
- # [[envoy]] 各种资源类型的解释
	- Envoy常见名词：
		- Downstream：请求 envoy 的对象。
		- Upstream：上游主机收到来自 Envoy 的连接请求同时相应该请求，类似 Kong 里面的 Target。
		- Cluster：一组逻辑上相似的上游主机。类似 Kong 里面的 Upstream。
		- Listener: 监听器。监听来自 4 层后者 7 层的流量。
		- Listener Filter：类似一个 pipeline 来处理数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能
	- Envoy 配置包含四部分：
		- bootstrap：Envoy proxy 启动时加载的静态配置。
		- listeners：监听器相关配置，由 LDS 下发。
		- clusters： 包含动态和静态配置。动态配置由 CDS 下发。
		- routes：路由配置。包含动态和静态配置。动态配置有 RDS 下发。
	- 参考：
		- https://jimmysong.io/istio-handbook/data-plane/envoy-proxy-config-deep-dive.html
- # LATER 深入[[golang]] 定时器
	- 了解 golang的timer的常见用法，以及常见的坑，比如定时器泄漏
- # LATER 深入了解 [[golang]] 的sync.Pool
	- 参考：
		- https://www.sobyte.net/post/2022-03/think-in-sync-pool/
		- https://www.qcrao.com/2020/04/20/dive-into-go-sync-pool/#pack-unpack （未读）
		- https://zhuanlan.zhihu.com/p/110140126 （未读）
- # [[golang]] 并发编程模式
	- 这边文章介绍了使用goroutine和channel实现常见并发编程case，比如模仿tee、并发worker、Fan-in/Fan-out。
	- 参考：
		- https://github.com/luk4z7/go-concurrency-guide
- # LATER [[HTTP]]方法解析
	- PUT、POST、GET 等方法的异同？ 哪些是幂等的？
	- 内部实现大概是怎么样的？？
	- POST 存在两次请求？
- # LATER [[istio]] 流量劫持过程 #[[servicemesh]]
	- https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/
	  该文章介绍了istio-proxy如何劫持流量的详细过程。
# GetMesh是什么？ #servicemesh
	- Istio 的发布策略非常激进，正常企业不能这么快速完成变更、迭代。所以 GetMesh 做的事就是测试当前版本的 Istio 在多个 k8s 版本直接的兼容性，并且会针对 Istio 打上所需的安全或者错误修复的补丁更新。简单来说比上游提供更稳定的支持。
- # [[istio]] 中的发现选择器 #[[servicemesh]]
- 在常规配置中，Istio 会观察 k8s 所有资源的更新。也就是说，一个服务的更新，会把这次更新下发到所有命令空间的 sidecar 中。当 Mesh 扩大后这种问题会严重拖慢性能，所以在 Istio 1.10 中引入了发现选择器。它允许我们控制 Istio 平面观察和发送配置更新的命名空间。
- # [[istio]] 中 VirtualService 和 Gateway 的联系
- 两者都有 host 字段用来匹配 host。如果 VirtualService 中定义的host 没有包含在某个 Gateway 中，那么就会继续找下一个 Gateway。直到找到合适，否则会返回404（已验证过）。
- 下图举例说明了这种关系：
- ![Pasted Image 20220523221100.png](../assets/Pasted_Image_20220523221100_1656461673483_0.png)
- # 理解[[js]]中的箭头函数
-
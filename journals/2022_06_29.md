- # 至多包含两个不同字符串的最长子串 #[[alg/again]]
- [159. 至多包含两个不同字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)
- 讲述了滑动窗口的大致解题思路
  https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solution/hua-dong-chuang-kou-zhen-di-jian-dan-yi-73bii/
- # 相隔为 1 的编辑举例 #[[alg/again]]
	- [161. 相隔为 1 的编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/one-edit-distance/)
	- 这道题虽然写出来了，但是实现过程还可以再优雅一点。
- # 重建二叉树 #[[alg/again]]
	- [剑指 Offer 07. 重建二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)
	- 难度不大，但是这道题经常做到，会用到前序遍历、中序遍历、递归等知识点，可以多练习一次。
- # 单词的最大乘积 #[[alg/again]]
	- [剑指 Offer II 005. 单词长度的最大乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/aseY1I/)
	- 优化点：将单词中的字幕字母映射到 0-25 的数字中，然后使用位与算法，可以计算出每个单词的值。如果两个单词的值进行 &，大于 0 则表示存在重复。
- # [[算法]]学习路径 #[[alg/schedule]]
	- **目标：**
		- 大多数数据结构的题都要做过，并且实现相应的数据结构。数组、链表、跳表、队列、栈、优先队列、二叉树、前缀树、并查集。
		- 了解常见的算法。比如 dfs、bfs、滑动窗口、单调栈、动态规划。
	- **资源：**
	- 剑指 offer（第 2 版）：https://leetcode.cn/problem-list/xb9nqhhg/
	- leetcode hot 100：https://leetcode.cn/problem-list/2cktkvj/
	- 程序员面试金典（第 6 版）：https://leetcode.cn/problem-list/xb9lfcwi/
- # 旋转数组最小值 #[[alg/again]]
	- [剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode）](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)
	- 算是二分法的变式。需要注意当 nums[mid] == nums[left] 时，是无法判断区间的，需要将 right = right - 1，在做判断。 为什么不能用 nums[mid] 和 nums[left]进行判断？因为当 nums[mid] > nums[left] 时并不能判断最小数在哪个区域，有歧义。 比如下面两个数组使用nums[mid] 和 nums[left] 进行判断结果是错误的：
	  [1,2,3,4,5]
	  [3,4,5,1,2]
	- 参考：
		- https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/
- # 最长不含重复字符的字符串 #[[alg/again]]
	- [剑指 Offer 48. 最长不含重复字符的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)
	- 通用方法是使用一个状态数组+快慢指针来解决。
- # 数组中出现次数超过一半的数字 #[[alg/again]]
	- [剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)
	- 这道题也可以用快速单边排序来做，但是使用摩尔投票法会更加地快速。
- # 二叉搜索树与双向链表 #[[alg/again]]
	- [剑指 Offer 36. 二叉搜索树与双向链表 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)
	- 中序遍历确定顺序，前后指针连接。
	- 参考：
		- https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
- # 二叉搜索树的后序遍历 #[[alg/again]]
	- [剑指 Offer 33. 二叉搜索树的后序遍历序列 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)
	- 主要是用到了分治的思想，把整棵树是否为二叉搜索树分割成左子树和右子树是否是二叉搜索树这两个子问题。
- # 栈的压入、弹出序列 #[[alg/again]]
	- [剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode）](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)
	- 新建辅助栈，注意退出的边界条件。
- # 表示数值的字符串 #[[alg/again]]
	- [剑指 Offer 20. 表示数值的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)
	- 参考：
	  https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/
	- 可以看下状态机，以及评论里有一个用 c++实现的算法。注意边界条件。
- # 二进制中 1 的个数 #[[alg/again]]
	- [剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)
	- 这道题常规做法是循环，不过还可以通过 n & (n-1) 这个小技巧来快速找到 1 的个数。
	- 为什么这种算法行得通，得分两种情况讨论：
	  1. 低位是 1，那么 n&(n-1) = 0，去除了一个 1。
	  2. 低位为 0，那么 n-1，会把最近的一个 1 置为 0，然后后面 0 置为 1，n&(n-1)=0 结果不变。
	- 其实两种情况可以合并为一个结论：就是把最近的一个 1 置为，然后随后的 0 全部置为 1，结果 为 0。这样翻转 M（1 的个数），就能返回结果。
- # 数值的整数次方 #[[alg/again]]
	- [剑指 Offer 16. 数值的整数次方 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)
	- 递归方法比较清晰，如何使用非递归去解决问题？
	  递归是采用回溯，那么如何使用循环去描述自底向下的过程。
- # 树的子结构 #[[alg/again]]
	- [剑指 Offer 26. 树的子结构 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)
	- 改题目主要是使用了递归的思路。第一做了出来，但是解法比较耦合。新的解法将遍历 A 和判断 B 是否是 A 的子树这两个逻辑区分开发。更加直观。
- # 只出现一次的数字 #[[alg/again]]
	- [剑指 Offer II 004. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/WGki4K/)
	- 使用一个 64 长度的数组，存放每个数字的每位的值，因为只有一个元素出现过一次，其余都是 3 次，那么就可以对这个数组做 `arr[i] % 3` 的操作，拿到那个元素每一位的值，然后得出答案。
- # envoy 各种资源类型的解释 #[[envoy]]
	-